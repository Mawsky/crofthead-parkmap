<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crofthead Map Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-soft: #eef4ea;
      --frame-bg: #dfead6;
      --stroke: #4a4a4a;
      --hover-outline: #222;
    }
    html, body { height:100%; margin:0; background:var(--bg-soft); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { width:100%; margin:0 auto; display:flex; flex-direction:column; gap:0; }
    #wrap, #toolbar, #frame { line-height: 0; }
    #toolbar { margin-bottom: 0; }
    #frame { margin-top: 0; padding-top: 0; }
    #panel { padding:8px 12px; }
    /* Responsive aspect-ratio box; JS sets aspect-ratio: W/H */
    #frame {
      width: 100%;
      margin: 0 auto;
      background: transparent;
      position: relative;
      /* aspect-ratio set in JS after reading JSON */
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .pitch { opacity: 1; }
    /* Minimal borders + non-scaling stroke */
    .pitch { stroke: #000; stroke-opacity: 0.35; stroke-width:1px; vector-effect: non-scaling-stroke; }
    .pitch:hover { opacity: 1; stroke: #111; stroke-opacity:0.95; filter: drop-shadow(0 0 2px rgba(0,0,0,.45)); cursor: pointer; }
    .ownTag, .statusDot { pointer-events: none; }
    .legend-text { font-size: 9px; fill: #1f3a4a; dominant-baseline: middle; }
    .tip {
      position: fixed; pointer-events: none;
      background: #111; color: #fff;
      padding: 6px 8px; border-radius: 6px;
      font-size: 12px; opacity: 0; transition: opacity .12s;
      z-index: 10;
    }
#toolbar {
  display:flex; gap:8px; align-items:center; padding:0 12px;
  flex-wrap:nowrap; overflow-x:auto;
  background:#fff; border-bottom:1px solid #e6e6e6; color:#1f3a4a; min-height:56px;
}
@media (max-width:1280px){ #legend { display:none !important; } }
    #brandBlock { display:flex; align-items:center; justify-content:center; height:56px; padding:0 12px; background: currentColor; }
    #brandLogo { height:36px; width:auto; display:block; }
    .toolbar-title { margin-left:auto; font-weight:600; }
    select, button { padding:6px 8px; font:inherit; }
    .ticket {
      position: fixed; z-index: 20; max-width: 320px;
      background:#fff; border:1px solid #ddd; border-radius:10px;
      box-shadow:0 8px 24px rgba(0,0,0,.15); padding:10px 12px; font-size:13px;
    }
    .ticket h4 { margin:0 0 6px 0; font-size:14px; }
    .ticket .meta { color:#444; margin:4px 0; }
    .badges { display:flex; gap:6px; margin-top:6px; }
    .badge { background:#eee; border-radius:8px; padding:2px 6px; font-size:12px; }
    .hatch { fill:url(#diagonalHatch); }
    /* Pitch number labels */
    .numLabel {
      font-size: 5px;                   /* smaller (about half the previous size) */
      font-weight: 500;                 /* slightly lighter to feel narrower */
      font-stretch: condensed;          /* prefer condensed if available */
      letter-spacing: 0.1px;            /* tiny tracking so small text stays legible */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-anchor: middle;
      dominant-baseline: central;
      fill: #444;                       /* fainter text colour */
      stroke: #fff;                     /* white halo bubble */
      stroke-width: 2;                  /* thinner halo */
      paint-order: stroke fill;         /* draw halo behind fill */
      pointer-events: none;             /* ignore mouse so hover works on pitches */
      user-select: none;
      opacity: 0.9;                     /* overall fainter appearance */
    }
    .labels-hidden .numLabel { display: none; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="toolbar">
      <div id="brandBlock">
        <img id="brandLogo" src="./Crofthead_Harrison_Logo.jpeg" alt="Crofthead logo" />
      </div>
      <label>Zone:
        <select id="fZone"><option value="*">All</option></select>
      </label>
      <label>Ownership:
        <select id="fOwner">
          <option value="*">All</option>
          <option value="owner">Owner</option>
          <option value="park_let">Park-let</option>
          <option value="park_owned">Park-owned</option>
        </select>
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleNums" />
        Show pitch numbers
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleStatus" checked />
        Show status
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleOwnership" />
        Show ownership
      </label>
      <span id="legend" style="display:none"></span>
      <button id="showCleaning">Cleaning</button>
      <button id="showMaint">Maint</button>
      <button id="showEmpty">Empty plots</button>
      <button id="clearFilters">Clear</button>
      <div class="toolbar-title">Interactive demo</div>
    </div>
    <div id="frame">
      <svg id="map" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>
  <div id="tip" class="tip"></div>

  <script>
    // PASTE your Google Sheets *published CSV* URL below (File -> Share -> Publish to web -> CSV)
    const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTglxnUZq_o3OR9W7rmnuEOHLnGTFcXMqiGcCcysJe8HxeZOuhEhHsvJBLUyqitHd9ookW9LG7tBp4S/pub?output=csv';

    async function loadCSV(url) {
      const txt = await fetch(url, {cache:'no-store'}).then(r => r.text());
      const lines = txt.trim().split(/\r?\n/);
      const cols = lines.shift().split(',');
      const parse = line => {
        const vals = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s => s.replace(/^"|"$/g,''));
        const obj = {}; cols.forEach((c,i)=> obj[c]=vals[i] ?? '');
        return obj;
      };
      const rows = lines.map(parse);
      const byId = Object.fromEntries(rows.map(r => [r.id, r]));
      return { rows, byId, cols };
    }

    const norm = s => (s ?? '').toString().trim().toLowerCase().replace(/[\s-]+/g,'_');
    const getOwnership = t => {
      const v = norm(t?.ownership);
      return v || 'owner'; // treat blank as owner for demo
    };

    const OWN_BORDER = { owner:'#4C8BF5', park_let:'#7B61FF', park_owned:'#3A9B7A' };
    const STAT_FILL = {
      vacant:'#DDF5E4', booked:'#FFE2B5', occupied:'#FFF59E',
      turnaround:'#FFE0E0', out_of_service:'#FAD7DD', for_sale:'#E0ECFF',
      empty_plot:'#FFFFFF'
    };
    // Zone tints (very light); fallback generated from zone name if not in map
    const ZONE_TINT = Object.create(null); // optional explicit map: { carrick_view: 'hsla(210,70%,60%,0.20)', ... }
    function tintForZone(z){
      const key = norm(z);
      if (!key) return 'hsl(0,0%,86%)';
      if (ZONE_TINT[key]) return ZONE_TINT[key];
      // deterministic pastel from string
      let h = 0; for (let i=0;i<key.length;i++) h = (h*31 + key.charCodeAt(i)) >>> 0;
      h = h % 360; const s = 42, l = 85; // muted, pale solid tint
      return `hsl(${h}, ${s}%, ${l}%)`;
    }
    const STATUS_DOT = { cleaning:'#f2a900', maintenance:'#d64545', fees:'#7b61ff' };
    const titleCase = s => (s||'').toString().replace(/_/g,' ').replace(/\b\w/g, m=>m.toUpperCase());

    function colourFor(t){
      const raw = (t?.status ?? '').toString().trim().toLowerCase();
      const status = raw.replace(/[\s-]+/g,'_');
      const isEmpty = ['empty_plot','empty','empty_pitch','plot_only','vacant_plot'].includes(status);
      const hasZone = !!(t?.zone && t.zone.trim());
      const hasPitch = !!(t?.pitch_no && t.pitch_no.trim());
      const isUnassigned = !isEmpty && (!hasZone || !hasPitch);

      let fill;
      if (isEmpty) {
        fill = '#FFFFFF'; // true empty = white
      } else if (isUnassigned) {
        fill = '#E6E6E6'; // unassigned = grey
      } else {
        fill = tintForZone(t?.zone || '');
      }

      const extra = (status==='out_of_service') ? 'hatch' : '';
      const fillOpacity = isUnassigned ? 0.85 : 1;
      return { stroke: '#000', strokeOpacity: 0.28, fill, extra, fillOpacity };
    }
    function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }
  </script>

  <script>
    async function boot() {
      // 1) Load geometry
      const data = await fetch('crofthead_map.json').then(r => r.json());
      const W = data.slide.width_pt;
      const H = data.slide.height_pt;

      const svg = document.getElementById('map');
      const frame = document.getElementById('frame');

      function sizeFrame(){
        const toolbar = document.getElementById('toolbar');
        const available = Math.max(100, window.innerHeight - toolbar.offsetHeight);
        const widthNow = frame.clientWidth || window.innerWidth; // current frame width
        const ideal = widthNow * (H / W);                        // ideal height for this width
        const h = Math.min(available, ideal);                    // smart fit: no letterbox, no overflow
        frame.style.height = h + 'px';
}

      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      sizeFrame();
      window.addEventListener('resize', sizeFrame);

      // Layer for pitch number labels (kept above background, below ticket)
      const labelsLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      labelsLayer.setAttribute('id', 'labelsLayer');

      // Background image (optional)
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      bg.setAttribute('href', 'parkmap_background.png');
      bg.setAttribute('x', '0'); bg.setAttribute('y', '0');
      bg.setAttribute('width', W); bg.setAttribute('height', H);
      svg.appendChild(bg);

      // Hatch pattern for out_of_service fill
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const pattern = document.createElementNS('http://www.w3.org/2000/svg','pattern');
      pattern.setAttribute('id','diagonalHatch');
      pattern.setAttribute('patternUnits','userSpaceOnUse');
      pattern.setAttribute('width','6');
      pattern.setAttribute('height','6');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,6 l6,-6 M-1,1 l2,-2 M5,7 l2,-2');
      path.setAttribute('stroke','#b66');
      path.setAttribute('stroke-width','1');
      pattern.appendChild(path); defs.appendChild(pattern); svg.appendChild(defs);
      function buildSvgLegend(svg, zonesList){
  const NS = 'http://www.w3.org/2000/svg';
  const pad = 8, boxW = 170, lineH = 11, sw = 12, gap = 6;
  const offsetRight = 42; // nudge further left from the edge to avoid plots
  const g = document.createElementNS(NS, 'g');
  g.setAttribute('id','mapLegend');
  g.setAttribute('pointer-events','none');

  const bgRect = document.createElementNS(NS, 'rect');
  bgRect.setAttribute('x', W - boxW - pad - offsetRight);
  bgRect.setAttribute('y', pad + 6);
  bgRect.setAttribute('width', boxW);
  bgRect.setAttribute('height', 40);
  bgRect.setAttribute('rx', 8);
  bgRect.setAttribute('ry', 8);
  bgRect.setAttribute('fill', 'rgba(255,255,255,0.8)');
  bgRect.setAttribute('stroke', '#cfd8d3');
  bgRect.setAttribute('stroke-width', '1');
  g.appendChild(bgRect);

  let y = pad + 6 + 12;

  const title = document.createElementNS(NS,'text');
  title.setAttribute('x', W - boxW - pad - offsetRight + 10);
  title.setAttribute('y', y);
  title.setAttribute('class','legend-text');
  title.textContent = 'Legend';
  g.appendChild(title);
  y += 12;

  const zonesLabel = document.createElementNS(NS,'text');
  zonesLabel.setAttribute('x', W - boxW - pad - offsetRight + 10);
  zonesLabel.setAttribute('y', y);
  zonesLabel.setAttribute('class','legend-text');
  zonesLabel.textContent = 'Zones';
  g.appendChild(zonesLabel);
  y += 10;

  const shown = new Set();
  zonesList.forEach(zRaw => {
    const z = (zRaw||'').trim();
    if(!z || shown.has(z)) return; shown.add(z);
    const color = tintForZone(z);

    const r = document.createElementNS(NS,'rect');
    r.setAttribute('x', W - boxW - pad - offsetRight + 10);
    r.setAttribute('y', y - 8);
    r.setAttribute('width', sw);
    r.setAttribute('height', 10);
    r.setAttribute('fill', color);
    r.setAttribute('stroke', '#000');
    r.setAttribute('stroke-opacity', '0.25');
    r.setAttribute('vector-effect','non-scaling-stroke');
    g.appendChild(r);

    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', W - boxW - pad - offsetRight + 10 + sw + gap);
    t.setAttribute('y', y);
    t.setAttribute('class','legend-text');
    t.textContent = z;
    g.appendChild(t);

    y += lineH;
  });

  const statusHeader = document.createElementNS(NS,'text');
  statusHeader.setAttribute('x', W - boxW - pad - offsetRight + 10);
  statusHeader.setAttribute('y', y);
  statusHeader.setAttribute('class','legend-text');
  statusHeader.textContent = 'Status';
  g.appendChild(statusHeader);
  y += 10;

  const addDot = (label, color) => {
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('cx', W - boxW - pad - offsetRight + 15);
    c.setAttribute('cy', y - 3);
    c.setAttribute('r', 4);
    c.setAttribute('fill', color);
    g.appendChild(c);

    const tx = document.createElementNS(NS,'text');
    tx.setAttribute('x', W - boxW - pad - offsetRight + 24);
    tx.setAttribute('y', y - 1);
    tx.setAttribute('class','legend-text');
    tx.textContent = label;
    g.appendChild(tx);

    y += lineH;
  };
  addDot('Cleaning', STATUS_DOT.cleaning);
  addDot('Maint', STATUS_DOT.maintenance);

  const oosRect = document.createElementNS(NS,'rect');
  oosRect.setAttribute('x', W - boxW - pad - offsetRight + 10);
  oosRect.setAttribute('y', y - 10);
  oosRect.setAttribute('width', sw);
  oosRect.setAttribute('height', 10);
  oosRect.setAttribute('class','hatch');
  oosRect.setAttribute('fill', '#f7f7f7');
  oosRect.setAttribute('stroke', '#000');
  oosRect.setAttribute('stroke-opacity', '0.25');
  g.appendChild(oosRect);

  const oosT = document.createElementNS(NS,'text');
  oosT.setAttribute('x', W - boxW - pad - offsetRight + 10 + sw + gap);
  oosT.setAttribute('y', y - 1);
  oosT.setAttribute('class','legend-text');
  oosT.textContent = 'Out of service';
  g.appendChild(oosT);
  y += lineH;

  const ownHeader = document.createElementNS(NS,'text');
  ownHeader.setAttribute('x', W - boxW - pad - offsetRight + 10);
  ownHeader.setAttribute('y', y);
  ownHeader.setAttribute('class','legend-text');
  ownHeader.textContent = 'Ownership';
  g.appendChild(ownHeader);
  y += 10;

  const ownBox = document.createElementNS(NS,'rect');
  ownBox.setAttribute('x', W - boxW - pad - offsetRight + 10);
  ownBox.setAttribute('y', y - 10);
  ownBox.setAttribute('width', sw);
  ownBox.setAttribute('height', 10);
  ownBox.setAttribute('fill', '#eee');
  ownBox.setAttribute('stroke', '#000');
  ownBox.setAttribute('stroke-opacity', '0.25');
  g.appendChild(ownBox);

  const ownStripe = document.createElementNS(NS,'rect');
  ownStripe.setAttribute('x', W - boxW - pad - offsetRight + 10);
  ownStripe.setAttribute('y', y - 10);
  ownStripe.setAttribute('width', 4);
  ownStripe.setAttribute('height', 10);
  ownStripe.setAttribute('fill', OWN_BORDER.owner);
  g.appendChild(ownStripe);

  const ownText = document.createElementNS(NS,'text');
  ownText.setAttribute('x', W - boxW - pad - offsetRight + 10 + sw + gap);
  ownText.setAttribute('y', y - 1);
  ownText.setAttribute('class','legend-text');
  ownText.textContent = 'Stripe = ownership (when enabled)';
  g.appendChild(ownText);

  y += lineH;
  const totalH = (y + 4) - (pad + 8);
  bgRect.setAttribute('height', totalH);
  svg.appendChild(g);
}

      // 2) Load ticket data from Google Sheets (published CSV)
      let sheet = {rows:[], byId:{}};
      try { sheet = await loadCSV(SHEET_CSV_URL); } catch(e) { console.warn('Sheet load failed', e); }

      // Populate zone filter options
      const fZone = document.getElementById('fZone');
      const allZones = sheet.rows.map(r => (r.zone || '').trim());
      const hasEmptyZones = allZones.some(z => z === '');
      const zones = Array.from(new Set(allZones.filter(Boolean))).sort();
      zones.forEach(z => { const opt=document.createElement('option'); opt.value=norm(z); opt.textContent=z; fZone.appendChild(opt); });
      if (hasEmptyZones) {
        const optNone = document.createElement('option');
        optNone.value='__none__'; optNone.textContent='(Unassigned)';
        fZone.appendChild(optNone);
      }

      // 3) Draw shapes joined with ticket data
      const NS = 'http://www.w3.org/2000/svg';
      const nodes = [];
      const ownTagById = new Map();
      const statusDotById = new Map();
      data.shapes.sort((a,b)=> (a.z||0) - (b.z||0));
      for (const s of data.shapes) {
        if (s.type === 'Line') continue;
        const x = s.x_pct * W, y = s.y_pct * H, w = s.w_pct * W, h = s.h_pct * H;
        const el = document.createElementNS(NS, 'rect');
        el.setAttribute('x', x); el.setAttribute('y', y);
        el.setAttribute('width', w); el.setAttribute('height', h);
        if (s.rotation_deg) {
          const cx = x + w/2, cy = y + h/2;
          el.setAttribute('transform', `rotate(${s.rotation_deg} ${cx} ${cy})`);
        }
        const t = sheet.byId[s.id];
        const {stroke, fill, extra, strokeOpacity, fillOpacity} = colourFor(t);
        el.setAttribute('fill', fill);
        el.setAttribute('stroke', stroke);
        el.style.fillOpacity = (typeof fillOpacity !== 'undefined') ? String(fillOpacity) : '1';
        if (typeof strokeOpacity !== 'undefined') el.style.strokeOpacity = strokeOpacity;
        el.setAttribute('stroke-width', ((s.stroke_w_pt || 0.75) * 1.333));
        el.setAttribute('class', extra ? 'pitch hatch' : 'pitch');
        el.dataset.id = s.id;
        el.dataset.zone = norm(t?.zone);
        el.dataset.ownership = getOwnership(t);
        nodes.push(el);
        svg.appendChild(el);
        // Status dot (top-right inside the van)
        const dot = document.createElementNS(NS, 'circle');
        const r = Math.max(2.2, Math.min(w, h) * 0.16);
        let dx = w - r - 1, dy = r + 1;
        const cx = x + dx, cy = y + dy;
        dot.setAttribute('cx', cx);
        dot.setAttribute('cy', cy);
        dot.setAttribute('r', r);
        dot.setAttribute('class','statusDot');
        // colour will be set in updateStatusOverlays()
        if (s.rotation_deg) {
          const rcx = x + w/2, rcy = y + h/2;
          dot.setAttribute('transform', `rotate(${s.rotation_deg} ${rcx} ${rcy})`);
        }
        svg.appendChild(dot);
        statusDotById.set(s.id, dot);
        // Ownership left-edge stripe (hidden until toggled on)
        const own = getOwnership(t);
        const stripeW = Math.min(w * 0.14, 3.5);
        const tag = document.createElementNS(NS, 'rect');
        tag.setAttribute('x', x);
        tag.setAttribute('y', y);
        tag.setAttribute('width', stripeW);
        tag.setAttribute('height', h);
        tag.setAttribute('fill', OWN_BORDER[own] || '#4a4a4a');
        tag.setAttribute('class', 'ownTag');
        tag.setAttribute('vector-effect','non-scaling-stroke');
        tag.style.display = 'none';
        if (s.rotation_deg) {
          const rcx = x + w/2, rcy = y + h/2;
          tag.setAttribute('transform', `rotate(${s.rotation_deg} ${rcx} ${rcy})`);
        }
        svg.appendChild(tag);
        ownTagById.set(s.id, tag);
      }
      function updateStatusOverlays(){
        const show = document.getElementById('toggleStatus').checked;
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id] || {};
          const dot = statusDotById.get(n.dataset.id);
          if (!dot) return;
          if (!show || n.style.display==='none') { dot.style.display='none'; return; }
          let color = '';
          if ((t.clean_status||'').toLowerCase()==='due') color = STATUS_DOT.cleaning;
          if ((t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) color = STATUS_DOT.maintenance;
          if ((t.site_fee_status||'').toLowerCase()==='overdue') color = STATUS_DOT.fees;
          if (color) { dot.setAttribute('fill', color); dot.style.display=''; }
          else { dot.style.display='none'; }
        });
        // handle hatch overlay for OOS
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id] || {};
          const raw = (t.status||'').toString().trim().toLowerCase();
          const status = raw.replace(/[\s-]+/g,'_');
          if (status==='out_of_service' && show) n.classList.add('hatch'); else n.classList.remove('hatch');
        });
      }

      function updateOwnershipOverlays(){
        const show = document.getElementById('toggleOwnership').checked;
        const legendOwn = document.getElementById('legendOwn');
        if (legendOwn) legendOwn.style.display = show ? '' : 'none';
        nodes.forEach(n => {
          const tag = ownTagById.get(n.dataset.id);
          if (!tag) return;
          tag.style.display = (show && n.style.display !== 'none') ? '' : 'none';
        });
      }
      buildSvgLegend(svg, zones);
      // Append labels layer last so it sits above background and pitches
      svg.appendChild(labelsLayer);
      // Build pitch number labels, centred on each pitch rect
      const labelById = new Map();
      function createOrUpdateLabel(node){
        const id = node.dataset.id;
        // Skip if node not visible (will sync later)
        const t = sheet.byId[id] || {};
        const textVal = (t.pitch_no && t.pitch_no.trim()) ? t.pitch_no.trim() : id;
        // Compute rect centre
        const x = parseFloat(node.getAttribute('x')) + parseFloat(node.getAttribute('width'))/2;
        const y = parseFloat(node.getAttribute('y')) + parseFloat(node.getAttribute('height'))/2;
        let textEl = labelById.get(id);
        if (!textEl){
          textEl = document.createElementNS(NS, 'text');
          textEl.classList.add('numLabel');
          labelById.set(id, textEl);
          labelsLayer.appendChild(textEl);
        }
        textEl.setAttribute('x', x);
        textEl.setAttribute('y', y);
        textEl.textContent = textVal;
      }

      function rebuildLabels(){
        nodes.forEach(n => createOrUpdateLabel(n));
        syncLabelVisibility();
      }

      function syncLabelVisibility(){
        const show = document.getElementById('toggleNums').checked;
        // Toggle all via a class for performance
        if (show){
          labelsLayer.classList.remove('labels-hidden');
        } else {
          labelsLayer.classList.add('labels-hidden');
        }
        // Also mirror per-node display state
        nodes.forEach(n => {
          const id = n.dataset.id;
          const textEl = labelById.get(id);
          if (!textEl) return;
          textEl.style.display = (n.style.display === 'none') ? 'none' : '';
        });
      }

      // 4) Ticket panel on hover/click
      const ticket = document.createElement('div');
      ticket.className = 'ticket hidden';
      document.body.appendChild(ticket);

      function showTicket(ev, id) {
        const t = sheet.byId[id] || {};
        const title = (t.pitch_no || id) + (t.zone ? ` — ${t.zone}` : '');
        const badges = [];
        if ((t.hot_tub||'').toLowerCase()==='yes') badges.push('♨︎ Hot tub');
        if ((t.clean_status||'').toLowerCase()==='due') badges.push('🧹 Cleaning');
        if ((t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) badges.push('🔧 Maintenance');
        if ((t.site_fee_status||'').toLowerCase()==='overdue') badges.push('£ Fees');

        ticket.innerHTML = `
          <h4>${title}</h4>
          <div class="meta">Type/Ownership: ${(t.unit_type||'—').toString().toUpperCase()} • ${(t.ownership||'—').replace('_',' ')}</div>
          <div class="meta">Status: ${t.status || '—'}</div>
          <div class="meta">Cleaning: ${t.clean_status || '—'}${t.last_cleaned ? ` (last: ${t.last_cleaned})` : ''}</div>
          ${(t.check_in||t.check_out) ? `<div class="meta">Booking: ${t.check_in || '—'} → ${t.check_out || '—'}</div>` : `<div class="meta">Booking: —</div>`}
          <div class="meta">Fees: ${t.site_fee_status || '—'}${t.for_sale_price ? ` • For sale £${t.for_sale_price}` : ''}</div>
          ${(t.gas_cp12_expiry||t.elec_safety_check_date||t.smoke_co_check_date) ? `
            <div class="meta">Compliance: ${t.gas_cp12_expiry?`Gas CP12 ${t.gas_cp12_expiry}`:''}${t.elec_safety_check_date?`${t.gas_cp12_expiry?' • ':''}Elec ${t.elec_safety_check_date}`:''}${t.smoke_co_check_date?`${(t.gas_cp12_expiry||t.elec_safety_check_date)?' • ':''}Alarms ${t.smoke_co_check_date}`:''}</div>
          ` : `<div class="meta">Compliance: —</div>`}
          ${t.issue_summary ? `<div class="meta">Maintenance: ${t.maint_status || 'issue'} • ${t.issue_summary}</div>` : `<div class="meta">Maintenance: ${t.maint_status || '—'}</div>`}
          ${t.amenities_listed ? `<div class="meta">Amenities: ${t.amenities_listed}</div>` : ''}
          ${badges.length ? `<div class="badges">${badges.map(b=>`<span class=\"badge\">${b}</span>`).join('')}</div>` : ''}
          ${t.notes ? `<div class="meta" style="margin-top:6px;color:#666;">${t.notes}</div>` : ''}
        `;
        ticket.classList.remove('hidden');
        const pad = 12, w = 320, h = 180;
        const x = clamp(ev.clientX + 14, 8, window.innerWidth - w - pad);
        const y = clamp(ev.clientY + 14, 8, window.innerHeight - h - pad);
        ticket.style.left = x + 'px';
        ticket.style.top  = y + 'px';
      }
      function hideTicket(){ ticket.classList.add('hidden'); }

      svg.addEventListener('mousemove', ev => {
        const t = ev.target;
        if (t.classList && t.classList.contains('pitch')) showTicket(ev, t.dataset.id); else hideTicket();
      });
      svg.addEventListener('mouseleave', hideTicket);
      svg.addEventListener('click', ev => {
        if (ev.target.classList.contains('pitch')) showTicket(ev, ev.target.dataset.id);
      });
      document.addEventListener('click', ev => {
        if (!ev.target.closest('.ticket') && !ev.target.closest('#map')) hideTicket();
      });

      // 5) Filters
      function applyFilters() {
        const z = document.getElementById('fZone').value.toLowerCase();
        const o = document.getElementById('fOwner').value.toLowerCase();
        nodes.forEach(n => {
          const okZ = (z==='*' || (z==='__none__' ? (n.dataset.zone==='') : (n.dataset.zone===z)));
          const okO = (o==='*' || n.dataset.ownership===o);
          n.style.display = (okZ && okO) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
      }
      document.getElementById('fZone').onchange = applyFilters;
      document.getElementById('fOwner').onchange = applyFilters;

      document.getElementById('showCleaning').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.clean_status||'').toLowerCase()==='due') ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('showMaint').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('showEmpty').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          const raw = (t?.status ?? '').toString().trim().toLowerCase();
          const status = raw.replace(/[\s-]+/g,'_');
          const isEmpty = ['empty_plot','empty','empty_pitch','plot_only','vacant_plot'].includes(status);
          n.style.display = isEmpty ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('clearFilters').onclick = () => {
        document.getElementById('fZone').value='*';
        document.getElementById('fOwner').value='*';
        applyFilters();
        syncLabelVisibility();
        updateStatusOverlays();
        updateOwnershipOverlays();
      };

      // Pitch number toggle
      const toggle = document.getElementById('toggleNums');
      toggle.addEventListener('change', syncLabelVisibility);
      document.getElementById('toggleStatus').addEventListener('change', updateStatusOverlays);
      document.getElementById('toggleOwnership').addEventListener('change', updateOwnershipOverlays);

      // Build labels once geometry is present
      rebuildLabels();
      updateStatusOverlays();
      updateOwnershipOverlays();
    }
    boot();
  </script>
</body>
</html>