<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crofthead Map Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-soft: #eef4ea;
      --frame-bg: #dfead6;
      --stroke: #4a4a4a;
      --hover-outline: #222;
    }
    html, body { height:100%; margin:0; background:var(--bg-soft); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { width:100%; margin:0 auto; }
    #panel { padding:8px 12px; }
    /* Responsive aspect-ratio box; JS sets aspect-ratio: W/H */
    #frame {
      width: 100%;
      margin: 0 auto;
      background: var(--frame-bg);
      position: relative;
      /* aspect-ratio set in JS after reading JSON */
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .pitch { opacity: 0.95; }
    .pitch:hover { opacity: 1; outline: 2px solid var(--hover-outline); cursor: pointer; }
    .tip {
      position: fixed; pointer-events: none;
      background: #111; color: #fff;
      padding: 6px 8px; border-radius: 6px;
      font-size: 12px; opacity: 0; transition: opacity .12s;
      z-index: 10;
    }
    #toolbar { display:flex; gap:12px; align-items:center; padding:0 12px; flex-wrap:wrap; background:#fff; border-bottom:1px solid #e6e6e6; color:#1f3a4a; min-height:56px; }
    #brandBlock { display:flex; align-items:center; justify-content:center; height:56px; padding:0 12px; background: currentColor; }
    #brandLogo { height:36px; width:auto; display:block; }
    .toolbar-title { margin-left:auto; font-weight:600; }
    select, button { padding:6px 8px; font:inherit; }
    .ticket {
      position: fixed; z-index: 20; max-width: 320px;
      background:#fff; border:1px solid #ddd; border-radius:10px;
      box-shadow:0 8px 24px rgba(0,0,0,.15); padding:10px 12px; font-size:13px;
    }
    .ticket h4 { margin:0 0 6px 0; font-size:14px; }
    .ticket .meta { color:#444; margin:4px 0; }
    .badges { display:flex; gap:6px; margin-top:6px; }
    .badge { background:#eee; border-radius:8px; padding:2px 6px; font-size:12px; }
    .hatch { fill:url(#diagonalHatch); }
    /* Pitch number labels */
    .numLabel {
      font-size: 10px;
      font-weight: 600;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-anchor: middle;
      dominant-baseline: central;
      fill: #111;                /* text colour */
      stroke: #fff;              /* white halo bubble */
      stroke-width: 3;           /* thickness of halo */
      paint-order: stroke fill;  /* draw halo behind fill */
      pointer-events: none;      /* ignore mouse so hover works on pitches */
      user-select: none;
    }
    .labels-hidden .numLabel { display: none; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="toolbar">
      <div id="brandBlock">
        <img id="brandLogo" src="./Crofthead_Harrison_Logo.jpeg" alt="Crofthead logo" />
      </div>
      <label>Zone:
        <select id="fZone"><option value="*">All</option></select>
      </label>
      <label>Ownership:
        <select id="fOwner">
          <option value="*">All</option>
          <option value="owner">Owner</option>
          <option value="park_let">Park-let</option>
          <option value="park_owned">Park-owned</option>
        </select>
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleNums" />
        Show pitch numbers
      </label>
      <button id="showCleaning">Cleaning due</button>
      <button id="showMaint">Maintenance</button>
      <button id="showEmpty">Empty plots</button>
      <button id="clearFilters">Clear</button>
      <div class="toolbar-title">Interactive demo</div>
    </div>
    <div id="frame">
      <svg id="map" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>
  <div id="tip" class="tip"></div>

  <script>
    // PASTE your Google Sheets *published CSV* URL below (File -> Share -> Publish to web -> CSV)
    const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTglxnUZq_o3OR9W7rmnuEOHLnGTFcXMqiGcCcysJe8HxeZOuhEhHsvJBLUyqitHd9ookW9LG7tBp4S/pub?output=csv';

    async function loadCSV(url) {
      const txt = await fetch(url, {cache:'no-store'}).then(r => r.text());
      const lines = txt.trim().split(/\r?\n/);
      const cols = lines.shift().split(',');
      const parse = line => {
        const vals = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s => s.replace(/^"|"$/g,''));
        const obj = {}; cols.forEach((c,i)=> obj[c]=vals[i] ?? '');
        return obj;
      };
      const rows = lines.map(parse);
      const byId = Object.fromEntries(rows.map(r => [r.id, r]));
      return { rows, byId, cols };
    }

    const norm = s => (s ?? '').toString().trim().toLowerCase().replace(/[\s-]+/g,'_');
    const getOwnership = t => {
      const v = norm(t?.ownership);
      return v || 'owner'; // treat blank as owner for demo
    };

    const OWN_BORDER = { owner:'#4C8BF5', park_let:'#7B61FF', park_owned:'#3A9B7A' };
    const STAT_FILL = {
      vacant:'#DDF5E4', booked:'#FFE2B5', occupied:'#FFF59E',
      turnaround:'#FFE0E0', out_of_service:'#FAD7DD', for_sale:'#E0ECFF',
      empty_plot:'#FFFFFF'
    };

    function colourFor(t){
      // Normalise status to be forgiving: spaces/dashes -> underscore
      const raw = (t?.status ?? '').toString().trim().toLowerCase();
      const status = raw.replace(/[\s-]+/g,'_');

      // Treat common aliases as empty plots
      const isEmpty = status === 'empty_plot' || status === 'empty' || status === 'empty_pitch' || status === 'plot_only' || status === 'vacant_plot';
      if (isEmpty) {
        return { stroke: '#999999', fill: '#FFFFFF', extra: '' };
      }

      const own = getOwnership(t);
      const stroke = OWN_BORDER[own] || '#4a4a4a';
      let fill = STAT_FILL[status] || '#b3b3b3';
      const extra = status==='out_of_service' ? 'hatch' : '';
      return {stroke, fill, extra};
    }
    function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }
  </script>

  <script>
    async function boot() {
      // 1) Load geometry
      const data = await fetch('crofthead_map.json').then(r => r.json());
      const W = Math.round(data.slide.width_pt);
      const H = Math.round(data.slide.height_pt);

      const svg = document.getElementById('map');
      const frame = document.getElementById('frame');
      frame.style.aspectRatio = `${W} / ${H}`;
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

      // Layer for pitch number labels (kept above background, below ticket)
      const labelsLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      labelsLayer.setAttribute('id', 'labelsLayer');

      // Background image (optional)
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      bg.setAttribute('href', 'parkmap_background.png');
      bg.setAttribute('x', '0'); bg.setAttribute('y', '0');
      bg.setAttribute('width', W); bg.setAttribute('height', H);
      svg.appendChild(bg);

      // Hatch pattern for out_of_service fill
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const pattern = document.createElementNS('http://www.w3.org/2000/svg','pattern');
      pattern.setAttribute('id','diagonalHatch');
      pattern.setAttribute('patternUnits','userSpaceOnUse');
      pattern.setAttribute('width','6');
      pattern.setAttribute('height','6');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,6 l6,-6 M-1,1 l2,-2 M5,7 l2,-2');
      path.setAttribute('stroke','#b66');
      path.setAttribute('stroke-width','1');
      pattern.appendChild(path); defs.appendChild(pattern); svg.appendChild(defs);

      // 2) Load ticket data from Google Sheets (published CSV)
      let sheet = {rows:[], byId:{}};
      try { sheet = await loadCSV(SHEET_CSV_URL); } catch(e) { console.warn('Sheet load failed', e); }

      // Populate zone filter options
      const fZone = document.getElementById('fZone');
      const allZones = sheet.rows.map(r => (r.zone || '').trim());
      const hasEmptyZones = allZones.some(z => z === '');
      const zones = Array.from(new Set(allZones.filter(Boolean))).sort();
      zones.forEach(z => { const opt=document.createElement('option'); opt.value=norm(z); opt.textContent=z; fZone.appendChild(opt); });
      if (hasEmptyZones) {
        const optNone = document.createElement('option');
        optNone.value='__none__'; optNone.textContent='(Unassigned)';
        fZone.appendChild(optNone);
      }

      // 3) Draw shapes joined with ticket data
      const NS = 'http://www.w3.org/2000/svg';
      const nodes = [];
      data.shapes.sort((a,b)=> (a.z||0) - (b.z||0));
      for (const s of data.shapes) {
        if (s.type === 'Line') continue;
        const x = s.x_pct * W, y = s.y_pct * H, w = s.w_pct * W, h = s.h_pct * H;
        const el = document.createElementNS(NS, 'rect');
        el.setAttribute('x', x); el.setAttribute('y', y);
        el.setAttribute('width', w); el.setAttribute('height', h);
        if (s.rotation_deg) {
          const cx = x + w/2, cy = y + h/2;
          el.setAttribute('transform', `rotate(${s.rotation_deg} ${cx} ${cy})`);
        }
        const t = sheet.byId[s.id];
        const {stroke, fill, extra} = colourFor(t);
        el.setAttribute('fill', fill);
        el.setAttribute('stroke', stroke);
        el.setAttribute('stroke-width', ((s.stroke_w_pt || 0.75) * 1.333));
        el.setAttribute('class', extra ? 'pitch hatch' : 'pitch');
        el.dataset.id = s.id;
        el.dataset.zone = norm(t?.zone);
        el.dataset.ownership = getOwnership(t);
        nodes.push(el);
        svg.appendChild(el);
      }
      // Append labels layer last so it sits above background and pitches
      svg.appendChild(labelsLayer);
      // Build pitch number labels, centred on each pitch rect
      const labelById = new Map();
      function createOrUpdateLabel(node){
        const id = node.dataset.id;
        // Skip if node not visible (will sync later)
        const t = sheet.byId[id] || {};
        const textVal = (t.pitch_no && t.pitch_no.trim()) ? t.pitch_no.trim() : id;
        // Compute rect centre
        const x = parseFloat(node.getAttribute('x')) + parseFloat(node.getAttribute('width'))/2;
        const y = parseFloat(node.getAttribute('y')) + parseFloat(node.getAttribute('height'))/2;
        let textEl = labelById.get(id);
        if (!textEl){
          textEl = document.createElementNS(NS, 'text');
          textEl.classList.add('numLabel');
          labelById.set(id, textEl);
          labelsLayer.appendChild(textEl);
        }
        textEl.setAttribute('x', x);
        textEl.setAttribute('y', y);
        textEl.textContent = textVal;
      }

      function rebuildLabels(){
        nodes.forEach(n => createOrUpdateLabel(n));
        syncLabelVisibility();
      }

      function syncLabelVisibility(){
        const show = document.getElementById('toggleNums').checked;
        // Toggle all via a class for performance
        if (show){
          labelsLayer.classList.remove('labels-hidden');
        } else {
          labelsLayer.classList.add('labels-hidden');
        }
        // Also mirror per-node display state
        nodes.forEach(n => {
          const id = n.dataset.id;
          const textEl = labelById.get(id);
          if (!textEl) return;
          textEl.style.display = (n.style.display === 'none') ? 'none' : '';
        });
      }

      // 4) Ticket panel on hover/click
      const ticket = document.createElement('div');
      ticket.className = 'ticket hidden';
      document.body.appendChild(ticket);

      function showTicket(ev, id) {
        const t = sheet.byId[id] || {};
        const title = (t.pitch_no || id) + (t.zone ? ` â€” ${t.zone}` : '');
        const badges = [];
        if ((t.hot_tub||'').toLowerCase()==='yes') badges.push('â™¨ï¸Ž Hot tub');
        if ((t.clean_status||'').toLowerCase()==='due') badges.push('ðŸ§¹ Cleaning');
        if ((t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) badges.push('ðŸ”§ Maintenance');
        if ((t.site_fee_status||'').toLowerCase()==='overdue') badges.push('Â£ Fees');

        ticket.innerHTML = `
          <h4>${title}</h4>
          <div class="meta">Type/Ownership: ${(t.unit_type||'â€”').toString().toUpperCase()} â€¢ ${(t.ownership||'â€”').replace('_',' ')}</div>
          <div class="meta">Status: ${t.status || 'â€”'}</div>
          <div class="meta">Cleaning: ${t.clean_status || 'â€”'}${t.last_cleaned ? ` (last: ${t.last_cleaned})` : ''}</div>
          ${(t.check_in||t.check_out) ? `<div class="meta">Booking: ${t.check_in || 'â€”'} â†’ ${t.check_out || 'â€”'}</div>` : `<div class="meta">Booking: â€”</div>`}
          <div class="meta">Fees: ${t.site_fee_status || 'â€”'}${t.for_sale_price ? ` â€¢ For sale Â£${t.for_sale_price}` : ''}</div>
          ${(t.gas_cp12_expiry||t.elec_safety_check_date||t.smoke_co_check_date) ? `
            <div class="meta">Compliance: ${t.gas_cp12_expiry?`Gas CP12 ${t.gas_cp12_expiry}`:''}${t.elec_safety_check_date?`${t.gas_cp12_expiry?' â€¢ ':''}Elec ${t.elec_safety_check_date}`:''}${t.smoke_co_check_date?`${(t.gas_cp12_expiry||t.elec_safety_check_date)?' â€¢ ':''}Alarms ${t.smoke_co_check_date}`:''}</div>
          ` : `<div class="meta">Compliance: â€”</div>`}
          ${t.issue_summary ? `<div class="meta">Maintenance: ${t.maint_status || 'issue'} â€¢ ${t.issue_summary}</div>` : `<div class="meta">Maintenance: ${t.maint_status || 'â€”'}</div>`}
          ${t.amenities_listed ? `<div class="meta">Amenities: ${t.amenities_listed}</div>` : ''}
          ${badges.length ? `<div class="badges">${badges.map(b=>`<span class=\"badge\">${b}</span>`).join('')}</div>` : ''}
          ${t.notes ? `<div class="meta" style="margin-top:6px;color:#666;">${t.notes}</div>` : ''}
        `;
        ticket.classList.remove('hidden');
        const pad = 12, w = 320, h = 180;
        const x = clamp(ev.clientX + 14, 8, window.innerWidth - w - pad);
        const y = clamp(ev.clientY + 14, 8, window.innerHeight - h - pad);
        ticket.style.left = x + 'px';
        ticket.style.top  = y + 'px';
      }
      function hideTicket(){ ticket.classList.add('hidden'); }

      svg.addEventListener('mousemove', ev => {
        const t = ev.target;
        if (t.classList && t.classList.contains('pitch')) showTicket(ev, t.dataset.id); else hideTicket();
      });
      svg.addEventListener('mouseleave', hideTicket);
      svg.addEventListener('click', ev => {
        if (ev.target.classList.contains('pitch')) showTicket(ev, ev.target.dataset.id);
      });
      document.addEventListener('click', ev => {
        if (!ev.target.closest('.ticket') && !ev.target.closest('#map')) hideTicket();
      });

      // 5) Filters
      function applyFilters() {
        const z = document.getElementById('fZone').value.toLowerCase();
        const o = document.getElementById('fOwner').value.toLowerCase();
        nodes.forEach(n => {
          const okZ = (z==='*' || (z==='__none__' ? (n.dataset.zone==='') : (n.dataset.zone===z)));
          const okO = (o==='*' || n.dataset.ownership===o);
          n.style.display = (okZ && okO) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
        });
      }
      document.getElementById('fZone').onchange = applyFilters;
      document.getElementById('fOwner').onchange = applyFilters;

      document.getElementById('showCleaning').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.clean_status||'').toLowerCase()==='due') ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
        });
      };
      document.getElementById('showMaint').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
        });
      };
      document.getElementById('showEmpty').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          const raw = (t?.status ?? '').toString().trim().toLowerCase();
          const status = raw.replace(/[\s-]+/g,'_');
          const isEmpty = ['empty_plot','empty','empty_pitch','plot_only','vacant_plot'].includes(status);
          n.style.display = isEmpty ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
        });
      };
      document.getElementById('clearFilters').onclick = () => {
        document.getElementById('fZone').value='*';
        document.getElementById('fOwner').value='*';
        applyFilters();
        syncLabelVisibility();
      };

      // Pitch number toggle
      const toggle = document.getElementById('toggleNums');
      toggle.addEventListener('change', syncLabelVisibility);

      // Build labels once geometry is present
      rebuildLabels();
    }
    boot();
  </script>
</body>
</html>