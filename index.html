<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crofthead Map Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-soft: #eef4ea;
      --frame-bg: #dfead6;
      --stroke: #4a4a4a;
      --hover-outline: #222;
      --toolbar-h: 56px; /* will be updated at runtime */
    }
    html, body { height:100%; margin:0; background:var(--bg-soft); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { width:100%; margin:0 auto; display:grid; grid-template-rows:auto 1fr; min-height:100svh; gap:0; }
    #wrap { line-height: 0; }
    #toolbar { margin-bottom: 0; }
    #frame { margin-top: 0; padding-top: 0; }
    #panel { padding:8px 12px; }
    /* Responsive aspect-ratio box; JS sets aspect-ratio: W/H */
    #frame {
      width: 100%;
      margin: 0 auto;
      background: transparent;
      position: relative;
      height: calc(100vh - var(--toolbar-h) + 2px);  /* fallback */
      height: calc(100svh - var(--toolbar-h) + 2px);  /* small viewport height */
      height: calc(100dvh - var(--toolbar-h) + 2px);  /* dynamic viewport height (best) */
      /* aspect-ratio set in JS after reading JSON */
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .pitch { opacity: 1; }
    /* Minimal borders + non-scaling stroke */
    .pitch { stroke: #000; stroke-opacity: 0.35; stroke-width:1px; vector-effect: non-scaling-stroke; }
    .pitch:hover { opacity: 1; stroke: #111; stroke-opacity:0.95; filter: drop-shadow(0 0 2px rgba(0,0,0,.45)); cursor: pointer; }
    .ownTag, .statusDot { pointer-events: none; }
    .legend-text { font-size: 8px; fill: #1f3a4a; dominant-baseline: middle; }
    #legendDrag{ cursor: move; }
    #legendResize{ cursor: se-resize; }
    .tip {
      position: fixed; pointer-events: none;
      background: #111; color: #fff;
      padding: 6px 8px; border-radius: 6px;
      font-size: 12px; opacity: 0; transition: opacity .12s;
      z-index: 10;
    }
  #toolbar {
    display:flex; gap:8px; align-items:center; padding:0 12px;
    flex-wrap: wrap;                 /* allow wrapping on narrow widths */
    background:#fff; border-bottom:1px solid #e6e6e6; color:#1f3a4a; min-height:56px;
  }
  .tool { display:flex; align-items:center; gap:6px; white-space:nowrap; flex:0 0 auto; }
@media (max-width:1280px){ #legend { display:none !important; } }

@media (max-width: 1024px){
  #toolbar { flex-wrap: wrap; row-gap: 6px; }
  #toolbar label { font-size: 14px; }
  #toolbar button { padding:4px 8px; }
  .toolbar-title { display:none; }
  select { max-width: 150px; }
}
    #brandBlock { display:flex; align-items:center; justify-content:center; height:56px; padding:0 12px; background: currentColor; }
    #brandLogo { height:36px; width:auto; display:block; }
    .toolbar-title { margin-left:auto; font-weight:600; }
    select, button { padding:6px 8px; font:inherit; }
    .ticket {
      position: fixed; z-index: 20; max-width: 320px;
      background:#fff; border:1px solid #ddd; border-radius:10px;
      box-shadow:0 8px 24px rgba(0,0,0,.15); padding:10px 12px; font-size:13px;
    }
    .ticket h4 { margin:0 0 6px 0; font-size:14px; }
    .ticket .meta { color:#444; margin:4px 0; }
    .badges { display:flex; gap:6px; margin-top:6px; }
    .badge { background:#eee; border-radius:8px; padding:2px 6px; font-size:12px; }
    .hatch { fill:url(#diagonalHatch); }
    /* Pitch number labels */
    .numLabel {
      font-size: 5px;                   /* smaller (about half the previous size) */
      font-weight: 500;                 /* slightly lighter to feel narrower */
      font-stretch: condensed;          /* prefer condensed if available */
      letter-spacing: 0.1px;            /* tiny tracking so small text stays legible */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-anchor: middle;
      dominant-baseline: central;
      fill: #444;                       /* fainter text colour */
      stroke: #fff;                     /* white halo bubble */
      stroke-width: 2;                  /* thinner halo */
      paint-order: stroke fill;         /* draw halo behind fill */
      pointer-events: none;             /* ignore mouse so hover works on pitches */
      user-select: none;
      opacity: 0.9;                     /* overall fainter appearance */
    }
    .labels-hidden .numLabel { display: none; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="toolbar">
      <div id="brandBlock">
        <img id="brandLogo" src="./Crofthead_Harrison_Logo.jpeg" alt="Crofthead logo" />
      </div>
      <label class="tool">Zone:
        <select id="fZone"><option value="*">All</option></select>
      </label>
      <label class="tool">Ownership:
        <select id="fOwner">
          <option value="*">All</option>
          <option value="owner">Owner</option>
          <option value="park_let">Park-let</option>
          <option value="park_owned">Park-owned</option>
        </select>
      </label>
      <label class="tool">
        <input type="checkbox" id="toggleNums" />
        Pitch #
      </label>
      <label class="tool">
        <input type="checkbox" id="toggleStatus" checked />
        Status
      </label>
      <label class="tool">
        <input type="checkbox" id="toggleLegend" checked />
        Legend
      </label>
      <label class="tool">
        <input type="checkbox" id="toggleOwnership" />
        Ownership
      </label>
      <span id="legend" style="display:none"></span>
      <button id="showCleaning">Cleaning</button>
      <button id="showMaint">Maint</button>
      <button id="showEmpty">Empty plots</button>
      <button id="clearFilters">Clear</button>
      <div class="toolbar-title">Interactive demo</div>
    </div>
    <div id="frame">
      <svg id="map" preserveAspectRatio="xMidYMin meet"></svg>
    </div>
  </div>
  <div id="tip" class="tip"></div>

  <script>
    // PASTE your Google Sheets *published CSV* URL below (File -> Share -> Publish to web -> CSV)
    const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTglxnUZq_o3OR9W7rmnuEOHLnGTFcXMqiGcCcysJe8HxeZOuhEhHsvJBLUyqitHd9ookW9LG7tBp4S/pub?output=csv';

    async function loadCSV(url) {
      const txt = await fetch(url, {cache:'no-store'}).then(r => r.text());
      const lines = txt.trim().split(/\r?\n/);
      const cols = lines.shift().split(',');
      const parse = line => {
        const vals = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s => s.replace(/^"|"$/g,''));
        const obj = {}; cols.forEach((c,i)=> obj[c]=vals[i] ?? '');
        return obj;
      };
      const rows = lines.map(parse);
      const byId = Object.fromEntries(rows.map(r => [r.id, r]));
      return { rows, byId, cols };
    }

    const norm = s => (s ?? '').toString().trim().toLowerCase().replace(/[\s-]+/g,'_');
    const getOwnership = t => {
      const v = norm(t?.ownership);
      return v || 'owner'; // treat blank as owner for demo
    };

    const OWN_BORDER = { owner:'#4C8BF5', park_let:'#7B61FF', park_owned:'#3A9B7A' };
    const STAT_FILL = {
      vacant:'#DDF5E4', booked:'#FFE2B5', occupied:'#FFF59E',
      turnaround:'#FFE0E0', out_of_service:'#FAD7DD', for_sale:'#E0ECFF',
      empty_plot:'#FFFFFF'
    };
    // Zone tints (very light); fallback generated from zone name if not in map
    const ZONE_TINT = Object.create(null); // optional explicit map: { carrick_view: 'hsla(210,70%,60%,0.20)', ... }
    function tintForZone(z){
      const key = norm(z);
      if (!key) return 'hsl(0,0%,86%)';
      if (ZONE_TINT[key]) return ZONE_TINT[key];
      // deterministic pastel from string
      let h = 0; for (let i=0;i<key.length;i++) h = (h*31 + key.charCodeAt(i)) >>> 0;
      h = h % 360; const s = 42, l = 85; // muted, pale solid tint
      return `hsl(${h}, ${s}%, ${l}%)`;
    }
    const STATUS_DOT = { cleaning:'#f2a900', maintenance:'#d64545', fees:'#7b61ff' };
    const titleCase = s => (s||'').toString().replace(/_/g,' ').replace(/\b\w/g, m=>m.toUpperCase());

    function colourFor(t){
      const raw = (t?.status ?? '').toString().trim().toLowerCase();
      const status = raw.replace(/[\s-]+/g,'_');
      const isEmpty = ['empty_plot','empty','empty_pitch','plot_only','vacant_plot'].includes(status);
      const hasZone = !!(t?.zone && t.zone.trim());
      const hasPitch = !!(t?.pitch_no && t.pitch_no.trim());
      const isUnassigned = !isEmpty && (!hasZone || !hasPitch);

      let fill;
      if (isEmpty) {
        fill = '#FFFFFF'; // true empty = white
      } else if (isUnassigned) {
        fill = '#E6E6E6'; // unassigned = grey
      } else {
        fill = tintForZone(t?.zone || '');
      }

      const extra = (status==='out_of_service') ? 'hatch' : '';
      const fillOpacity = isUnassigned ? 0.85 : 1;
      return { stroke: '#000', strokeOpacity: 0.28, fill, extra, fillOpacity };
    }
    function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }
    // --- Legend state (position + scale) ---
const legendPos = { x: 0, y: 0, scale: 1 };

function loadLegendState(){
  try {
    const s = JSON.parse(localStorage.getItem('legendState') || '{}');
    if (typeof s.x === 'number') legendPos.x = s.x;
    if (typeof s.y === 'number') legendPos.y = s.y;
    if (typeof s.scale === 'number') legendPos.scale = s.scale;
  } catch {}
}

function saveLegendState(){
  localStorage.setItem('legendState', JSON.stringify(legendPos));
}
  </script>

  <script>
    async function boot() {
      // 1) Load geometry
      const data = await fetch('crofthead_map.json').then(r => r.json());
      const W = data.slide.width_pt;
      const H = data.slide.height_pt;

      const svg = document.getElementById('map');
      const frame = document.getElementById('frame');

      const toolbarEl = document.getElementById('toolbar');
      function setToolbarVar(){
        const th = toolbarEl.getBoundingClientRect().height;
        document.documentElement.style.setProperty('--toolbar-h', th + 'px');
      }

      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      setToolbarVar();
      new ResizeObserver(setToolbarVar).observe(toolbarEl);
      window.addEventListener('resize', setToolbarVar);
      window.addEventListener('orientationchange', setToolbarVar);

      // Layer for pitch number labels (kept above background, below ticket)
      const labelsLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      labelsLayer.setAttribute('id', 'labelsLayer');

      // Solid base to avoid any visible gaps from PNG transparency
      const base = document.createElementNS('http://www.w3.org/2000/svg','rect');
      base.setAttribute('x','0'); base.setAttribute('y','0');
      base.setAttribute('width', W); base.setAttribute('height', H);
      base.setAttribute('fill','#5f7657'); // average grass tone
      svg.appendChild(base);

      // Background image (optional)
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      bg.setAttribute('href', 'parkmap_background.png');
      bg.setAttribute('x', '0'); bg.setAttribute('y', '0');
      bg.setAttribute('width', W); bg.setAttribute('height', H);
      svg.appendChild(bg);

      // Hatch pattern for out_of_service fill
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const pattern = document.createElementNS('http://www.w3.org/2000/svg','pattern');
      pattern.setAttribute('id','diagonalHatch');
      pattern.setAttribute('patternUnits','userSpaceOnUse');
      pattern.setAttribute('width','6');
      pattern.setAttribute('height','6');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,6 l6,-6 M-1,1 l2,-2 M5,7 l2,-2');
      path.setAttribute('stroke','#b66');
      path.setAttribute('stroke-width','1');
      pattern.appendChild(path); defs.appendChild(pattern); svg.appendChild(defs);
      // SVG text wrapping helper for legend
      function wrapSvgText(textEl, str, maxWidth){
        while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
        const words = (str||'').split(/\s+/);
        let line = '';
        const makeTspan = (dy) => {
          const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
          tspan.setAttribute('x', textEl.getAttribute('x'));
          tspan.setAttribute('dy', dy);
          textEl.appendChild(tspan);
          return tspan;
        };
        let tspan = makeTspan('0');
        words.forEach((w) => {
          const test = line ? line + ' ' + w : w;
          tspan.textContent = test;
          if (tspan.getComputedTextLength() > maxWidth && line){
            tspan.textContent = line;
            tspan = makeTspan('1.25em');
            tspan.textContent = w;
            line = w;
          } else {
            line = test;
          }
        });
      }

      function buildSvgLegend(svg, zonesList){
        const NS = 'http://www.w3.org/2000/svg';
        // Slim legend (same look, now moveable/resizable)
        const pad = 12, boxW = 140, lineH = 12, sw = 12, gap = 6;
        const offsetRight = 90;

        // Draw everything at (0,0) in local legend coordinates
        const bgX = 0, bgY = 0;

        const g = document.createElementNS(NS, 'g');
        g.setAttribute('id','mapLegend');
        g.setAttribute('pointer-events','visiblePainted'); // allow interaction on handles

        // Content group (allow pointer events for specific children)
        const content = document.createElementNS(NS, 'g');
        content.setAttribute('id','legendContent');
        // allow pointer events for specific children (e.g., resize hotspot)
        content.setAttribute('pointer-events','auto');

        // Background panel
        const bgRect = document.createElementNS(NS, 'rect');
        bgRect.setAttribute('x', 0);
        bgRect.setAttribute('y', 0);
        bgRect.setAttribute('width', boxW);
        bgRect.setAttribute('height', 40);
        bgRect.setAttribute('rx', 8);
        bgRect.setAttribute('ry', 8);
        bgRect.setAttribute('fill', 'rgba(255,255,255,0.92)');
        bgRect.setAttribute('stroke', '#bfc8c2');
        bgRect.setAttribute('stroke-width', '1');
        // do not capture clicks on the panel itself
        bgRect.setAttribute('pointer-events','none');
        content.appendChild(bgRect);

        let y = 12;

        // Title
        const title = document.createElementNS(NS,'text');
        title.setAttribute('x', 12);
        title.setAttribute('y', y);
        title.setAttribute('class','legend-text');
        title.setAttribute('style','font-weight:600;font-size:8px;');
        title.textContent = 'Legend';
        content.appendChild(title);
        y += lineH + 2;

        // Zones header
        const zonesHdr = document.createElementNS(NS,'text');
        zonesHdr.setAttribute('x', 12);
        zonesHdr.setAttribute('y', y);
        zonesHdr.setAttribute('class','legend-text');
        zonesHdr.setAttribute('style','font-weight:500;font-size:7.5px;');
        zonesHdr.textContent = 'Zones';
        content.appendChild(zonesHdr);
        y += lineH;

        // Unique, sorted zones with wrapping
        const zones = Array.from(new Set(zonesList.filter(z => z && z.trim()))).sort();
        const maxLabelW = boxW - 12 - sw - gap - 12;
        zones.forEach(z => {
          const r = document.createElementNS(NS,'rect');
          r.setAttribute('x', 12);
          r.setAttribute('y', y - 8);
          r.setAttribute('width', sw);
          r.setAttribute('height', 10);
          r.setAttribute('fill', tintForZone(z));
          r.setAttribute('stroke', '#000');
          r.setAttribute('stroke-opacity', '0.25');
          r.setAttribute('vector-effect','non-scaling-stroke');
          content.appendChild(r);

          const t = document.createElementNS(NS,'text');
          t.setAttribute('x', 12 + sw + gap);
          t.setAttribute('y', y);
          t.setAttribute('class','legend-text');
          wrapSvgText(t, z, maxLabelW);
          content.appendChild(t);

          const lines = t.getElementsByTagName('tspan').length || 1;
          y += lineH * lines;
        });

        y += 6; // spacer before Status

        // Status header
        const statusHdr = document.createElementNS(NS,'text');
        statusHdr.setAttribute('x', 12);
        statusHdr.setAttribute('y', y);
        statusHdr.setAttribute('class','legend-text');
        statusHdr.setAttribute('style','font-weight:500;font-size:7.5px;');
        statusHdr.textContent = 'Status';
        content.appendChild(statusHdr);
        y += lineH;

        const addDot = (label, color) => {
          const c = document.createElementNS(NS,'circle');
          c.setAttribute('cx', 20);
          c.setAttribute('cy', y - 3);
          c.setAttribute('r', 4);
          c.setAttribute('fill', color);
          c.setAttribute('stroke', '#333');
          c.setAttribute('stroke-width', '0.5');
          content.appendChild(c);

          const tx = document.createElementNS(NS,'text');
          tx.setAttribute('x', 30);
          tx.setAttribute('y', y);
          tx.setAttribute('class','legend-text');
          wrapSvgText(tx, label, maxLabelW - 12);
          content.appendChild(tx);

          const lines = tx.getElementsByTagName('tspan').length || 1;
          y += lineH * lines;
        };
        addDot('Cleaning', STATUS_DOT.cleaning);
        addDot('Maint', STATUS_DOT.maintenance);

        // Out of service swatch
        const oosRect = document.createElementNS(NS,'rect');
        oosRect.setAttribute('x', 12);
        oosRect.setAttribute('y', y - 8);
        oosRect.setAttribute('width', sw);
        oosRect.setAttribute('height', 10);
        oosRect.setAttribute('class','hatch');
        oosRect.setAttribute('fill', '#f7f7f7');
        oosRect.setAttribute('stroke', '#000');
        oosRect.setAttribute('stroke-opacity', '0.25');
        content.appendChild(oosRect);

        const oosT = document.createElementNS(NS,'text');
        oosT.setAttribute('x', 12 + sw + gap);
        oosT.setAttribute('y', y);
        oosT.setAttribute('class','legend-text');
        wrapSvgText(oosT, 'Out of service', maxLabelW);
        content.appendChild(oosT);
        y += lineH;

        // Ownership header
        const ownHdr = document.createElementNS(NS,'text');
        ownHdr.setAttribute('x', 12);
        ownHdr.setAttribute('y', y);
        ownHdr.setAttribute('class','legend-text');
        ownHdr.setAttribute('style','font-weight:500;font-size:7.5px;');
        ownHdr.textContent = 'Ownership';
        content.appendChild(ownHdr);
        y += lineH;

        const ownBox = document.createElementNS(NS,'rect');
        ownBox.setAttribute('x', 12);
        ownBox.setAttribute('y', y - 8);
        ownBox.setAttribute('width', sw);
        ownBox.setAttribute('height', 10);
        ownBox.setAttribute('fill', '#eee');
        ownBox.setAttribute('stroke', '#000');
        ownBox.setAttribute('stroke-opacity', '0.25');
        content.appendChild(ownBox);

        const ownStripe = document.createElementNS(NS,'rect');
        ownStripe.setAttribute('x', 12);
        ownStripe.setAttribute('y', y - 8);
        ownStripe.setAttribute('width', 4);
        ownStripe.setAttribute('height', 10);
        ownStripe.setAttribute('fill', OWN_BORDER.owner);
        content.appendChild(ownStripe);

        // Force two-line ownership note
        const ownText = document.createElementNS(NS,'text');
        ownText.setAttribute('x', 12 + sw + gap);
        ownText.setAttribute('y', y);
        ownText.setAttribute('class','legend-text');
        const t1 = document.createElementNS(NS,'tspan');
        t1.setAttribute('x', 12 + sw + gap);
        t1.setAttribute('dy', '0');
        t1.textContent = 'Stripe = ownership';
        ownText.appendChild(t1);
        const t2 = document.createElementNS(NS,'tspan');
        t2.setAttribute('x', 12 + sw + gap);
        t2.setAttribute('dy', '1.25em');
        t2.textContent = '(when enabled)';
        ownText.appendChild(t2);
        content.appendChild(ownText);
        y += lineH * 2;

        // Commit content and compute panel height
        g.appendChild(content);
        const totalH = (y + pad - 10);

        // If legendPos is at (0,0), set initial position near top-right
        if (legendPos.x === 0 && legendPos.y === 0) {
          legendPos.x = W - boxW - offsetRight;
          legendPos.y = pad + 24;
        }

        // Adjust bg height now content is laid out
        const rectEl = g.querySelector('rect');
        rectEl.setAttribute('height', totalH);

        // --- Drag + resize handles (interactive) ---
        // Drag: transparent strip across header, full width, height 18
        const drag = document.createElementNS(NS,'rect');
        drag.setAttribute('x', 0);
        drag.setAttribute('y', 0);
        drag.setAttribute('width', boxW);
        drag.setAttribute('height', 18);
        drag.setAttribute('fill', 'transparent');
        drag.setAttribute('id', 'legendDrag');

        // Append content first, then drag overlay
        g.appendChild(content);
        g.appendChild(drag);

        // Resize handle: invisible hotspot anchored to bottom-right, inside content group
        const resize = document.createElementNS(NS,'rect');
        resize.setAttribute('x', boxW - 12);
        resize.setAttribute('y', totalH - 12);
        resize.setAttribute('width', 12);
        resize.setAttribute('height', 12);
        resize.setAttribute('fill', 'transparent');
        resize.setAttribute('stroke', 'none');
        resize.setAttribute('pointer-events','all'); // ensure it receives events even when content is scaled
        resize.setAttribute('id', 'legendResize');
        content.appendChild(resize);

        // Position & scale from saved state
        applyLegendTransform(g);
        svg.appendChild(g);
      }
      function applyLegendTransform(g){
        // translate group; scale inner content anchored at top-left
        g.setAttribute('transform', `translate(${legendPos.x},${legendPos.y})`);
        const c = document.getElementById('legendContent');
        if (c) c.setAttribute('transform', `scale(${legendPos.scale})`);
      }

      function svgPointFromClient(ev){
        const pt = svg.createSVGPoint();
        const c = ('touches' in ev) ? ev.touches[0] : ev;
        pt.x = c.clientX; pt.y = c.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      }

      function wireLegendInteractions(){
        const g = document.getElementById('mapLegend');
        if (!g) return;
        const drag = document.getElementById('legendDrag');
        const rez  = document.getElementById('legendResize');

        // Drag to move
        if (drag){
          let dragging=false, start, origin;
          drag.addEventListener('pointerdown', ev=>{
            dragging=true; drag.setPointerCapture(ev.pointerId);
            start = svgPointFromClient(ev); origin={x:legendPos.x,y:legendPos.y};
          });
          drag.addEventListener('pointermove', ev=>{
            if(!dragging) return;
            const p=svgPointFromClient(ev);
            legendPos.x = origin.x + (p.x-start.x);
            legendPos.y = origin.y + (p.y-start.y);
            applyLegendTransform(g);
          });
          drag.addEventListener('pointerup', ()=>{ dragging=false; saveLegendState(); });
        }

        // Drag corner to resize (scale)
        if (rez){
          let resizing=false, s0=legendPos.scale, x0=0;
          rez.addEventListener('pointerdown', ev=>{
            resizing=true; rez.setPointerCapture(ev.pointerId);
            s0=legendPos.scale; x0=ev.clientX;
          });
          rez.addEventListener('pointermove', ev=>{
            if(!resizing) return;
            const dx = ev.clientX - x0;
            legendPos.scale = Math.max(0.7, Math.min(1.6, s0 + dx/300));
            applyLegendTransform(g);
          });
          rez.addEventListener('pointerup', ()=>{ resizing=false; saveLegendState(); });
        }
      }
      // 2) Load ticket data from Google Sheets (published CSV)
      let sheet = {rows:[], byId:{}};
      try { sheet = await loadCSV(SHEET_CSV_URL); } catch(e) { console.warn('Sheet load failed', e); }

      // Populate zone filter options
      const fZone = document.getElementById('fZone');
      const allZones = sheet.rows.map(r => (r.zone || '').trim());
      const hasEmptyZones = allZones.some(z => z === '');
      const zones = Array.from(new Set(allZones.filter(Boolean))).sort();
      zones.forEach(z => { const opt=document.createElement('option'); opt.value=norm(z); opt.textContent=z; fZone.appendChild(opt); });
      if (hasEmptyZones) {
        const optNone = document.createElement('option');
        optNone.value='__none__'; optNone.textContent='(Unassigned)';
        fZone.appendChild(optNone);
      }
      // Load legend position/scale from previous session
      loadLegendState();
      // 3) Draw shapes joined with ticket data
      const NS = 'http://www.w3.org/2000/svg';
      const nodes = [];
      const ownTagById = new Map();
      const statusDotById = new Map();
      data.shapes.sort((a,b)=> (a.z||0) - (b.z||0));
      for (const s of data.shapes) {
        if (s.type === 'Line') continue;
        const x = s.x_pct * W, y = s.y_pct * H, w = s.w_pct * W, h = s.h_pct * H;
        const el = document.createElementNS(NS, 'rect');
        el.setAttribute('x', x); el.setAttribute('y', y);
        el.setAttribute('width', w); el.setAttribute('height', h);
        if (s.rotation_deg) {
          const cx = x + w/2, cy = y + h/2;
          el.setAttribute('transform', `rotate(${s.rotation_deg} ${cx} ${cy})`);
        }
        const t = sheet.byId[s.id];
        const {stroke, fill, extra, strokeOpacity, fillOpacity} = colourFor(t);
        el.setAttribute('fill', fill);
        el.setAttribute('stroke', stroke);
        el.style.fillOpacity = (typeof fillOpacity !== 'undefined') ? String(fillOpacity) : '1';
        if (typeof strokeOpacity !== 'undefined') el.style.strokeOpacity = strokeOpacity;
        el.setAttribute('stroke-width', ((s.stroke_w_pt || 0.75) * 1.333));
        el.setAttribute('class', extra ? 'pitch hatch' : 'pitch');
        el.dataset.id = s.id;
        el.dataset.zone = norm(t?.zone);
        el.dataset.ownership = getOwnership(t);
        nodes.push(el);
        svg.appendChild(el);
        // Status dot (top-right inside the van)
        const dot = document.createElementNS(NS, 'circle');
        const r = Math.max(2.2, Math.min(w, h) * 0.16);
        let dx = w - r - 1, dy = r + 1;
        const cx = x + dx, cy = y + dy;
        dot.setAttribute('cx', cx);
        dot.setAttribute('cy', cy);
        dot.setAttribute('r', r);
        dot.setAttribute('class','statusDot');
        // colour will be set in updateStatusOverlays()
        if (s.rotation_deg) {
          const rcx = x + w/2, rcy = y + h/2;
          dot.setAttribute('transform', `rotate(${s.rotation_deg} ${rcx} ${rcy})`);
        }
        svg.appendChild(dot);
        statusDotById.set(s.id, dot);
        // Ownership left-edge stripe (hidden until toggled on)
        const own = getOwnership(t);
        const stripeW = Math.min(w * 0.14, 3.5);
        const tag = document.createElementNS(NS, 'rect');
        tag.setAttribute('x', x);
        tag.setAttribute('y', y);
        tag.setAttribute('width', stripeW);
        tag.setAttribute('height', h);
        tag.setAttribute('fill', OWN_BORDER[own] || '#4a4a4a');
        tag.setAttribute('class', 'ownTag');
        tag.setAttribute('vector-effect','non-scaling-stroke');
        tag.style.display = 'none';
        if (s.rotation_deg) {
          const rcx = x + w/2, rcy = y + h/2;
          tag.setAttribute('transform', `rotate(${s.rotation_deg} ${rcx} ${rcy})`);
        }
        svg.appendChild(tag);
        ownTagById.set(s.id, tag);
      }
      function updateStatusOverlays(){
        const show = document.getElementById('toggleStatus').checked;
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id] || {};
          const dot = statusDotById.get(n.dataset.id);
          if (!dot) return;
          if (!show || n.style.display==='none') { dot.style.display='none'; return; }
          let color = '';
          if ((t.clean_status||'').toLowerCase()==='due') color = STATUS_DOT.cleaning;
          if ((t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) color = STATUS_DOT.maintenance;
          if ((t.site_fee_status||'').toLowerCase()==='overdue') color = STATUS_DOT.fees;
          if (color) { dot.setAttribute('fill', color); dot.style.display=''; }
          else { dot.style.display='none'; }
        });
        // handle hatch overlay for OOS
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id] || {};
          const raw = (t.status||'').toString().trim().toLowerCase();
          const status = raw.replace(/[\s-]+/g,'_');
          if (status==='out_of_service' && show) n.classList.add('hatch'); else n.classList.remove('hatch');
        });
      }

      function updateOwnershipOverlays(){
        const show = document.getElementById('toggleOwnership').checked;
        const legendOwn = document.getElementById('legendOwn');
        if (legendOwn) legendOwn.style.display = show ? '' : 'none';
        nodes.forEach(n => {
          const tag = ownTagById.get(n.dataset.id);
          if (!tag) return;
          tag.style.display = (show && n.style.display !== 'none') ? '' : 'none';
        });
      }
      buildSvgLegend(svg, zones);
      wireLegendInteractions();
      function updateLegendVisibility(){
        const show = document.getElementById('toggleLegend').checked;
        const legend = document.getElementById('mapLegend');
        if (legend) legend.style.display = show ? '' : 'none';
      }
      document.getElementById('toggleLegend').addEventListener('change', updateLegendVisibility);
      updateLegendVisibility();
      // Append labels layer last so it sits above background and pitches
      svg.appendChild(labelsLayer);
      // Build pitch number labels, centred on each pitch rect
      const labelById = new Map();
      function createOrUpdateLabel(node){
        const id = node.dataset.id;
        // Skip if node not visible (will sync later)
        const t = sheet.byId[id] || {};
        const textVal = (t.pitch_no && t.pitch_no.trim()) ? t.pitch_no.trim() : id;
        // Compute rect centre
        const x = parseFloat(node.getAttribute('x')) + parseFloat(node.getAttribute('width'))/2;
        const y = parseFloat(node.getAttribute('y')) + parseFloat(node.getAttribute('height'))/2;
        let textEl = labelById.get(id);
        if (!textEl){
          textEl = document.createElementNS(NS, 'text');
          textEl.classList.add('numLabel');
          labelById.set(id, textEl);
          labelsLayer.appendChild(textEl);
        }
        textEl.setAttribute('x', x);
        textEl.setAttribute('y', y);
        textEl.textContent = textVal;
      }

      function rebuildLabels(){
        nodes.forEach(n => createOrUpdateLabel(n));
        syncLabelVisibility();
      }

      function syncLabelVisibility(){
        const show = document.getElementById('toggleNums').checked;
        // Toggle all via a class for performance
        if (show){
          labelsLayer.classList.remove('labels-hidden');
        } else {
          labelsLayer.classList.add('labels-hidden');
        }
        // Also mirror per-node display state
        nodes.forEach(n => {
          const id = n.dataset.id;
          const textEl = labelById.get(id);
          if (!textEl) return;
          textEl.style.display = (n.style.display === 'none') ? 'none' : '';
        });
      }

      // 4) Ticket panel on hover/click
      const ticket = document.createElement('div');
      ticket.className = 'ticket hidden';
      document.body.appendChild(ticket);

      function showTicket(ev, id) {
        const t = sheet.byId[id] || {};
        const title = (t.pitch_no || id) + (t.zone ? ` â€” ${t.zone}` : '');
        const badges = [];
        if ((t.hot_tub||'').toLowerCase()==='yes') badges.push('â™¨ï¸Ž Hot tub');
        if ((t.clean_status||'').toLowerCase()==='due') badges.push('ðŸ§¹ Cleaning');
        if ((t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) badges.push('ðŸ”§ Maintenance');
        if ((t.site_fee_status||'').toLowerCase()==='overdue') badges.push('Â£ Fees');

        ticket.innerHTML = `
          <h4>${title}</h4>
          <div class="meta">Type/Ownership: ${(t.unit_type||'â€”').toString().toUpperCase()} â€¢ ${(t.ownership||'â€”').replace('_',' ')}</div>
          <div class="meta">Status: ${t.status || 'â€”'}</div>
          <div class="meta">Cleaning: ${t.clean_status || 'â€”'}${t.last_cleaned ? ` (last: ${t.last_cleaned})` : ''}</div>
          ${(t.check_in||t.check_out) ? `<div class="meta">Booking: ${t.check_in || 'â€”'} â†’ ${t.check_out || 'â€”'}</div>` : `<div class="meta">Booking: â€”</div>`}
          <div class="meta">Fees: ${t.site_fee_status || 'â€”'}${t.for_sale_price ? ` â€¢ For sale Â£${t.for_sale_price}` : ''}</div>
          ${(t.gas_cp12_expiry||t.elec_safety_check_date||t.smoke_co_check_date) ? `
            <div class="meta">Compliance: ${t.gas_cp12_expiry?`Gas CP12 ${t.gas_cp12_expiry}`:''}${t.elec_safety_check_date?`${t.gas_cp12_expiry?' â€¢ ':''}Elec ${t.elec_safety_check_date}`:''}${t.smoke_co_check_date?`${(t.gas_cp12_expiry||t.elec_safety_check_date)?' â€¢ ':''}Alarms ${t.smoke_co_check_date}`:''}</div>
          ` : `<div class="meta">Compliance: â€”</div>`}
          ${t.issue_summary ? `<div class="meta">Maintenance: ${t.maint_status || 'issue'} â€¢ ${t.issue_summary}</div>` : `<div class="meta">Maintenance: ${t.maint_status || 'â€”'}</div>`}
          ${t.amenities_listed ? `<div class="meta">Amenities: ${t.amenities_listed}</div>` : ''}
          ${badges.length ? `<div class="badges">${badges.map(b=>`<span class=\"badge\">${b}</span>`).join('')}</div>` : ''}
          ${t.notes ? `<div class="meta" style="margin-top:6px;color:#666;">${t.notes}</div>` : ''}
        `;
        ticket.classList.remove('hidden');
        const pad = 12, w = 320, h = 180;
        const x = clamp(ev.clientX + 14, 8, window.innerWidth - w - pad);
        const y = clamp(ev.clientY + 14, 8, window.innerHeight - h - pad);
        ticket.style.left = x + 'px';
        ticket.style.top  = y + 'px';
      }
      function hideTicket(){ ticket.classList.add('hidden'); }

      svg.addEventListener('mousemove', ev => {
        const t = ev.target;
        if (t.classList && t.classList.contains('pitch')) showTicket(ev, t.dataset.id); else hideTicket();
      });
      svg.addEventListener('mouseleave', hideTicket);
      svg.addEventListener('click', ev => {
        if (ev.target.classList.contains('pitch')) showTicket(ev, ev.target.dataset.id);
      });
      document.addEventListener('click', ev => {
        if (!ev.target.closest('.ticket') && !ev.target.closest('#map')) hideTicket();
      });

      // 5) Filters
      function applyFilters() {
        const z = document.getElementById('fZone').value.toLowerCase();
        const o = document.getElementById('fOwner').value.toLowerCase();
        nodes.forEach(n => {
          const okZ = (z==='*' || (z==='__none__' ? (n.dataset.zone==='') : (n.dataset.zone===z)));
          const okO = (o==='*' || n.dataset.ownership===o);
          n.style.display = (okZ && okO) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
      }
      document.getElementById('fZone').onchange = applyFilters;
      document.getElementById('fOwner').onchange = applyFilters;

      document.getElementById('showCleaning').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.clean_status||'').toLowerCase()==='due') ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('showMaint').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          n.style.display = (t && (t.maint_status||'').toLowerCase()!=='ok' && t.maint_status) ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('showEmpty').onclick = () => {
        nodes.forEach(n => {
          const t = sheet.byId[n.dataset.id];
          const raw = (t?.status ?? '').toString().trim().toLowerCase();
          const status = raw.replace(/[\s-]+/g,'_');
          const isEmpty = ['empty_plot','empty','empty_pitch','plot_only','vacant_plot'].includes(status);
          n.style.display = isEmpty ? '' : 'none';
          const lbl = labelById.get(n.dataset.id);
          if (lbl) lbl.style.display = n.style.display === 'none' ? 'none' : '';
          const dot = statusDotById.get(n.dataset.id);
          if (dot) dot.style.display = (n.style.display==='none' || !document.getElementById('toggleStatus').checked) ? 'none' : dot.style.display;
          const tag = ownTagById.get(n.dataset.id);
          if (tag) tag.style.display = (n.style.display==='none' || !document.getElementById('toggleOwnership').checked) ? 'none' : tag.style.display;
        });
        updateStatusOverlays();
        updateOwnershipOverlays();
      };
      document.getElementById('clearFilters').onclick = () => {
        document.getElementById('fZone').value='*';
        document.getElementById('fOwner').value='*';
        applyFilters();
        syncLabelVisibility();
        updateStatusOverlays();
        updateOwnershipOverlays();
      };

      // Pitch number toggle
      const toggle = document.getElementById('toggleNums');
      toggle.addEventListener('change', syncLabelVisibility);
      document.getElementById('toggleStatus').addEventListener('change', updateStatusOverlays);
      document.getElementById('toggleOwnership').addEventListener('change', updateOwnershipOverlays);

      // Build labels once geometry is present
      rebuildLabels();
      updateStatusOverlays();
      updateOwnershipOverlays();
    }
    boot();
  </script>
</body>
</html>